# Points du programme relevant

## Première NSI

Pas très adapté, la plupart des algos sont bien trop haut niveau pour la classe première, mais ça peut-être bien de mentionner leur existence (on ne transforme pas du texte en programme par magie)

- PREM 1A: techniquement relevant, les techniques de parsing c'est important ça a permis les premiers compilos etc
- PREM 7A: à la limite, exemples sur un mini-language

## Terminale NSI

Encore une fois pas très adapté, mais on s'en rapproche !

J'hésite à parler des graphes aussi, dans le sens "sous-expressions communes" etc, comme une alternative aux AST qui peut avoir son utilité

- TERM 1A: same as PREM 1A
- TERM 2D: notion d'arbre syntaxique
- TERM 6A: peut-être rapprochement parsing/interprétation, typiquement avec une calculatrice polonaise ?

## Prépa

Des bouts, mais pas vraiment de parsing

- PREPA 1B: caractère compilé/interprété d'un language
- PREPA 1D/1E: parler de la complexité/correction des algorithmes de parsing c'est important pour les comparer
- PREPA 2A: entrée = une suite de caractères, sortie = un AST/représentation intermédiaire
- PREPA 7C: Comma TERM 6A
- PREPA 10A: Je crois que CYK rentre dans ce cadre d'algro "brute-force", à voir
- PREPA 18: parser de formules propositionnelles ?
- PREPA 24: à préciser pour donner un cadre formel à notre leçon, surement au début

## Programme complémentaire
- COMP 4A-B (c'est litérallement ce qu'on fait lol)

# Questions à David
- pour def language propre, écrire le formalisme ou alors la phrase complète (p89)
- On fait les automates à pile

# Trucs à faire
- mettre une convention pour terminaux OU non-terminaux, terminaux (x), non-terminaux (X)
- préciser le language d'une grammaire rendue propre
- peut-être pas parler des grammaires propres
- Ajouter un lemme de pompage parmis Barr-Hilel et Ogden (p 103 exemple de non-algébrique preuve Barr-Hillel, p 104 inhéremment ambigu)
- Remplacer Greibarch par exemple de tranformation
- Refaire def language LL(k) (p66 François)
- mettre côte à côte